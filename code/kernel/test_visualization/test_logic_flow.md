# Yat_Casched 调度器测试程序逻辑流程

本文档详细描述了用于测试 `Yat_Casched` 调度器的用户态程序的标准逻辑流程。该流程旨在准确衡量调度器在多-线程并发环境下的性能表现，特别是在缓存亲和性方面的优化效果。

流程图主要分为两个部分：**主线程控制流** 和 **工作线程执行流**。

---

## 1. 主线程控制流

主线程负责整个测试的初始化、任务分发、同步等待和最终结果的汇总。其执行步骤如下：

**流程图示:**
```mermaid
mindmap
  root((主线程控制流))
    A[开始]
    B{解析命令行参数}
    C[初始化全局环境]
    D[循环创建工作线程]
    E[等待所有工作线程完成]
    F[清理资源并报告结果]
    G[结束]
```

1.  **开始**
    *   程序入口点 (`main` 函数)。

2.  **解析命令行参数**
    *   读取用户输入，例如：
        *   要创建的线程数量 (`-t, --threads`)
        *   每个线程的任务执行次数 (`-i, --iterations`)
        *   要使用的调度策略 (例如 `cfs` 或 `yat`)
    *   这使得测试可以灵活配置和复用。

3.  **初始化全局环境**
    *   创建并初始化所有线程共享的数据结构，如全局计时器、共享计数器或同步屏障 (`pthread_barrier_t`)。

4.  **循环创建工作线程**
    *   在一个循环中调用 `pthread_create`，根据参数创建指定数量的工作线程。
    *   每个线程启动时会执行一个指定的任务函数。

5.  **等待所有工作线程完成**
    *   主线程调用 `pthread_join` 等待每一个子线程执行完毕。
    *   这确保了在所有计算任务完成之前，主线程不会提前退出或进行结果统计。

6.  **清理资源并报告结果**
    *   在所有线程结束后，进行最终的计算和报告。
    *   例如：计算总耗时、平均CPU切换次数等关键性能指标 (KPIs)。
    *   释放之前分配的所有内存和系统资源。

7.  **结束**
    *   程序正常退出。

---

## 2. 工作线程执行流

每个工作线程是实际的测试单元。它模拟一个计算密集型任务，并主动将其调度策略设置为 `SCHED_YAT_CASCHED`，以接受自定义调度器的管理。

**流程图示:**
```mermaid
mindmap
  root((工作线程执行流))
    H[开始]
    I{设置调度策略为 SCHED_YAT_CASCHED}
    J[执行计算密集型任务]
    K[(可选) 恢复默认调度策略]
    L[退出]
```

1.  **线程开始**
    *   从 `pthread_create` 调用后开始执行。

2.  **设置自身调度策略为 `SCHED_YAT_CASCHED`**
    *   **核心步骤**: 调用 `sched_setscheduler()` 系统调用。
    *   将当前线程的调度策略从默认的 `SCHED_OTHER` (CFS) 更改为 `SCHED_YAT_CASCHED` (ID: 8)。
    *   这是验证自定义调度器功能的关键。

3.  **执行计算密集型任务 (`job`)**
    *   进入一个循环，执行消耗CPU的计算任务。
    *   例如：矩阵乘法、计算圆周率等。
    *   这个过程会频繁触发调度器的决策，从而检验其性能。

4.  **(可选) 恢复默认调度策略**
    *   在任务循环结束后，可以调用 `sched_setscheduler()` 将调度策略恢复为 `SCHED_OTHER`。
    *   这是一个良好的编程实践，避免影响系统中其他进程。

5.  **线程退出**
    *   线程函数返回，线程生命周期结束。主线程中的 `pthread_join` 会因此返回。

---

## 3. 主线程与工作线程关系

以下图示进一步阐明主线程与工作线程之间的关系及其交互：

```mermaid
graph TD
    A[主线程: 开始] --> B{主线程: 解析命令行参数};
    B --> C[主线程: 初始化全局环境];
    C --> D[主线程: 调用 pthread_create 循环创建工作线程];
    
    D -- "为每个线程执行" --> E_subgraph;
    
    subgraph E_subgraph [工作线程执行流]
        direction LR
        I[线程开始] --> J{设置调度策略为<br>SCHED_YAT_CASCHED};
        J --> K[执行计算密集型任务];
        K --> L[(可选) 恢复<br>默认调度策略];
        L --> M[线程退出];
    end
    
    E_subgraph -- "所有线程完成后" --> F[主线程: 调用 pthread_join 等待所有线程完成];
    F --> G[主线程: 清理资源并报告结果];
    G --> H[主线程: 结束];
```

此图清晰地展示了主线程如何通过 `pthread_create` 启动多个工作线程，以及每个工作线程如何独立地执行其计算任务并在完成后通知主线程。
